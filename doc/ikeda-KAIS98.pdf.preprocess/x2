In Figure 5, ontology author (OA) is arranged above side and
GPN author (GPNA) left side.
Thin planes stand for languages, e.g.
the base and the left side correspond to the description level of CLOS.
Core task (C-Task) ontology is the task ontology independent of
task types.
Ideally Core task ontology should be constant and an
ontology authors concentrate on building the task specific (Task-S)
ontologies for new task types.
CLEPE provides ontology authors
with functions of editing and browsing both core task ontology, task
specific ontology and symbol level ontology, because our current
research interests include to fix the boundary between the three
ontologies.
The main work of a GPN author are as follows: (1) To describe
their own problem solving, (2) to make sure that his/her problem
solving knowledge represented by GPN is correctly interpreted by
the system, (3) to modify GPN if necessary.
Figure 6 shows the module structure of CLEPE.
In this figure,
rectangles and ellipses stand for the functional modules and data,
respectively.
Arrows linking modules stand for the data flow.
In the
following, we explain each module briefly.
the execution process to users.
In preparation for interpretation of the GPN
OA(C-Task)
 
written by a GPN author, CLEPE reads task
OA(Task-S)
ontology description represented with TOL.
Execution
Model
The task ontology description is translated into
GPN
TO-Editor
internal form by TOL-Parser and stored into
Information of
TO-Browser
ontology base.
Ontology Manager manages the
Execution model
ontology base and deals with the requests
TO/S
related to the ontology made by other modules,
TO/K-C
GPNA
Task-S Ontology
for example, inquiries for class information,
TO/K-L
creation of a class instance and so on.
Once a
GPNA
GPN author completes editing his/her own
CLOS
GPN, CLEPE initiates the GPN interpretation
C-Task Ontology
ExecuterInterface
process.
The functional modules in shaded
GPNportion of Figure 6 takes an internal form of
Editor
TOL-Interpreter
GPN-C
GPN from GPN-Parser and generates the
TO/0 TOL
conceptual-level execution model.
We call the
shaded portion ARM: Anaphoric Resolution
module.
We adopt a focus model as a basic
Figure.5 Overview of CLEPE
framework of anaphoric resolution.
Focus manager updates the focus
TOL-Parser parses the task ontology described with TOL.
model dynamically based on the constraints generated by the other
Ontology Manager manages ontology base and deals with the
modules.
Two types of constraints, that is, local constraints and global
requests for the class information or instance generation.
constraints, are generated in different manners.
For each generic
GPN-Parser parses a GPN
process, local constraints are composed based on the syntactic
Model Generator generates conceptual level execution model
structure of the generic process and the ontological meaning of each
by referring the object flow analyzed.
word.
After all the local constraints for the whole GPN are generated,
Working Memory Manager manages all the data related to the
global constraints are synthesized along the structure of the GPN by
object flow analysis.
anaphoric resolution engine.
It tries to find the consistent
Constraint Generator generates syntactic or pragmatic
correspondence relations among the objects appeared in the GPN
constraints as results of object flow analysis.
based on the local constraints and the latest focus model.
Focus
Anaphoric Resolution Engine identifies anaphoric reference
represents a set of objects which can be accessible from a certain
among objects based on the focus and constraints generated.
generic process.
Focus manager interprets constraints newly added
Focus Manager manages the focus which plays a key role in object
into WM and infer whether the presence of objects referred to by the
flow analysis.
constraints could change or not.
Once a consistent anaphoric relation
Executor interprets conceptual level execution model and shows
OA(TO/S)
LC
WM
GC
Anaphoric
Result
Refer
Regist
LC/GＣ
Focus
Manager
Update
Focus
Focus
Model
Ontology
Manager
Regist
anaphoric
results
Refer to
anaphoric
result
Co nstraint
Generator
Refer to class
definitions
Task -S
Ontology
Refer
Regist
WM
Manager
Refer to
anaphoric
results
Co re-Task
Ontology
Ontology
Base
Generate instance
Refer
TO -Bro wse r
Read class definitions
Refer to class
definitions
GPN-Parser
Read GPN
Parsing
Result
GPN
Execution Model
Read
execution model
Refer to LC
Refer to focus
Anaphoric
Resolution
Engine
TO L-Parser
Model
Generator
Figure.
6 Module structure of CLEPE
Generate
execution model
Executer
is established by ARM, the GPN is translated into conceptual level
execution model.
A GPN author can run the execution model with
executor.
In the following sections, we describe TOL and conceptual level
execution.
while dynamic constraint depends on task context.
For instance, the
membership of a solution in the solution class is permanently true.
On the other hand, a dynamic constraint of the optimality of a solution
depends on the context of object flow.
In the conceptual level
execution model, an object is generated based on static membership
and its history is represented by dynamic constraints.
So execution
at the level of conceptual level is defined as a history of the changes
of objects.
These two constraints are explicitly separated in the
definition of task ontology.
Figure 7 shows a rough image of a conceptual level execution.
The left side of the figure represents a problem solving knowledge
(TO/K-L model) about a 24 hour job assignment task.
In the TO/KL description, the problem solving knowledge is described with a set
of human friendly primitives.
The right side shows the conceptual
level execution model corresponding to the problem solving
knowledge.
Fragments headed by :sc and :dc are constraints inferred
by object flow analysis.
:sc and :dc fragments correspond to static
membership and a dynamic constraint, respectively.
The transition
from the input objects to the output one of assign process shows that
the output object is an instance of the assignment class and composed
of the two objects which are the output of the "pick-up" process and
one of the "select" process.
In terms of the conceptual level
vocabulary, we could say the role of "assign" process is to bind the
"picked-up job" and "selected nurse" together and produce a new
assignment.
The assignment set in the rectangle represents the output,
"partial solution," of loop structure.
One might say "I can't find any difference between the execution
model itself as a result of object flow analysis and the conceptual
level execution."
The difference would be more clearer by considering
the competence of "execution".
The major difference between the
model and execution is that the model captures the descriptive and
static aspect of task structure, while the execution captures the
substantial and dynamic aspect based on conceptual level
computational semantics.
At any time point during the execution,
user can make inquiries about any event of the execution, for example,
4.1 TOL: a language for describing task ontology
Figure 5 shows a hierarchy of ontology description language.
TOL/
0 at the bottom of the hierarchy provides description primitives for
ontology author and defines semantics of upper-layer language.
Therefore all the semantics of task ontology described with TOL
is specified ultimately at the level of TOL/0.
To say concretely, TOL/
0 specifies the meaning of generic concepts for describing problem
solving knowledge and provides some primitives for constructing
core task ontology.
Core task ontology author [OA(C-Task)] specifies the lexical
entities and conceptual ones using TOL/0 primitives, e.g. DefineTol-Core-Lexical-Word, Define-Tol-Core-Concept, etc. By reading
the specification of core task ontology into CLEPE, a set of conceptual
primitives at the TOL level is introduced.
Task specific ontology
author [OA(Task-S)] specifies the concepts appearing in the target
task type with TOL.
For example, the semantics of the verb "assign,"
which appears in the scheduling task type, is defined at TOL-level
by using Define-Tol-Verb.
4.2 Conceptual level execution
Once CLEPE established the consistent object flow of a GPN by
object flow analysis, a conceptual level execution model is generated.
Object flow specifies the history of each object run through the
problem solving model, for example, "when an object appears and
disappears," or "how the status of the object changes".
Since the
history is described at knowledge-level task ontology (TO/K) level,
a GPN author could easily understand the execution process of his/
her own GPN.
Related to this, there are some differences between an
object constraint and a status constraint.
The former is static and the
latter is dynamic.
Static membership is a permanent property of object
cor-obj
Solution Representation
Solution Representation
cor-obj
TO/K-L $Job
$Nurse
$Rsc
:sc $Rsc
TO/K-C
$Rcp
Rsc-G
Pick-up
Pick-up Job
:sc Rsc
:dc ((picked-up Rsc Rsc-G))
Rsc
Picked-up
$Rcp
:sc $Rcp
Select
Select Nurse
:sc Rcp
Rcp :dc ((selected Rcp $Rcp))
Selected
Assign Selected Nurse
to the Job
Assign
:sc Assignment
:dc ((Include Assignment Rsc)
(Include Assignment Rcp))
Assignment
:sc Data
Update
Update Load
:sc :Data
:dc ((updated Data))
check
Data
:sc Assignment-set
Assign:dc
ment((Include Assignment-set Assignment) set
Partial
(partial Assignment-set))
Figure 7 An image of conceptual level execution
Data
Updated
Activity
Object
Status
Kth iteration
$Rcp
Pickup Job
Rsck
Select Nurse
picked up
selected for
Rcpk
Assign Nurse to Job
consist-of
Assignmentk
Update Load
Load
Load
$Rcp
$Nurses
Check
Rcpk
Nurse-k
picked up (2) loop-invariant generate causality
Rsck
(K+1)th iteration
Rcpk
$Rcp
Pickup Job
Select Nurse
Assign Nurse to Job
Rsck'consist-of
picked up
RcpK'consist-of
(1) Part-Whole Causaity
selected for
Assignmentk
selected for
$Nurses
Assignmentk'
Update Load
$Job
member
Nurse-k
Check
Load
member
Nurse-k'
Job-k
Job-k'
Load
consist of
consist of
Assignment-k
Assignment-k'
member
$Assignment
Figure 8 Examples of Problem Solving Causality
"What types of objects still remain (after running the pickup process)
?" or "What objects are generated now (after nth execution of the
loop) ?" and system can answer the inquiries in the right situation.
By keeping the continuity from the symbol level program code to
conceptual level model, CLEPE can give the conceptual level
execution about the execution result at the symbol level.
5 Competence of Conceptual Model of
Problem Solving
Task ontology consists of a variety of axioms which play the important
role to realize most functions of CLEPE.
Because of space limitation,
here we will take up some of the axioms needed for conceptual level
execution and show an example of conceptual problem solving model
and its competence.
Conceptual level execution is a function which provides the trace
information of execution process of GPN in the appropriate abstract
level.
The function reduces the load of the end-users' work while
they are debugging the GPN.
In general, an end-user using a
conventional programming environment often feels uncomfortable,
because the abstract level of the trace information such as real data
is too low for them to matched it off against their understanding of
problem solving.
On the other hand, conceptual level execution
provides end-users with the conceptual level information which can
be easily mapped off against their understanding of the intended
behavior of GPN.
In the following, we introduce the concept of
problem solving causality which plays most important role for
generating appropriate information about the behavior of GPN .
The information provided by the conceptual level execution mainly
concerns on how objects and the relation among them change during
problem solving.
An idea of 'version' of objects is introduced as a
source of the information.
Change of version represents when and
how the change of an object or relation happened.
Furthermore,
changes of version are propagated over the model, for example, the
version change of part of an object is propagated to the whole object.
It reflects how end-users recognize the changes of objects in domain
world.
An important point, here, is that all the changes happened in
domain world should not be reported to end-users, because too much
information would bather them.
Instead, the report should include
only the information really useful for end-user to grasp problem
solving behavior clearly.
Problem solving causality is a set of axioms
needed to realize this summarization function.
Here, we show "(1)
part-whole causality" and "(2) Loop-invariant generate causality" as
examples.
Figure 8 shows object flow model (partially) and domain model
corresponding to it.
In object flow model, all the effects of an activity at each step of
GPN are represented.
In the domain model which corresponds to the
given task flow model, changes of domain objects caused by the
activities and the changes of relations among the objects are also
represented in terms of 'version.'
In figure 8, we discuss the relation among task flow and changes
of domain world objects taking the part-whole causal relation as an
example.
Let's focus on the causal relation between the update process
in kth iteration of the loop and the select process (which selects a
nurse with minimum load from a set of nurses) in (k+1)th iteration.
When update process updates the load data of the nurse who is
assigned to a job in assign process in kth iteration, we can say the
version of the nurse changes.
In addition to this, the set of nurses
including the nurse also changes its status.
This is the case that the
change of the part is propagated to the whole through the componentof relations among objects specified in the domain world.
However,
whether this propagation should be reported to end-users or not is a
matter for argument on problem solving causality.
Problem solving
causality answers the question based on whether the change is
important or not from problem solving viewpoint.
In this case, it is
important because the change of the set of nurse guarantees
correctness of the input to the select process in the succeeding
iteration.
Thus, when the select process is executed in (k+1)th iteration
of the loop, conceptual level execution shows end-users that the input
object of the select process is identical to one in kth iteration and the
load data of all its members are appropriately updated by update
process in kth iteration.
By representing the changes of objects caused
by task execution in terms of 'version of the domain object,' it is
possible for CLEPE to explain the behavior of problem solving at
arbitrary time in terms of appropriate expression.
For example,
concerning the roles of select process at every loop iteration, "the
select process, through all the loop iteration, selects a nurse with
minimal load from the set of the nurses whose load are adequately
updated by update process in the last itelation of the loop."
Another example is the one we call loop-invariant generate
causality.
In preparation, let us consider the life of a relation among
objects.
In Figure 8, we can see two types of relations, that is, looptemporal relations and permanent relations.
'Picked_up' binary
relation for the Jobk is an example of loop-temporal relation.
This
appears when pickup process outputs the Jobk in kth iteration of the
loop and disappears when the iteration is completed.
The same thing
is true for 'Selected for' relation for the Nursek.
The life span of the 'Picked_up' relation in the Pickup-Check loop
structure is specified by the axiom of task ontology.
The version
maintenance function of CLEPE sets up the life span of each instance
of the relation based on the axiom.
In case of the 'Selected_for'
relation, it becomes more complex.
In the axiom related to Select
process, there is no specification for the life span of the relation.
Instead, the general axiom of task ontology says that "if a conceptual
entity depends tightly on the other conceptual entities, the life span
of them should be same as a general rule."
Following the principle,
'Selected_for (Nursek,Picked_up(Jobk))' should disappear at the same
time that 'Picked_up(Jobk) disappears, because Nursek is
Selected_for 'Picked_up(Jobk).'
Here, however, we should notice that
the generic relations, Pickup_up(*) and Selected_for(*,*), form an
invariant structure through the iteration of the loop.
On the other hand, the consist-of relation among Assignment, Job
and Nurse is an example of permanent relation.
There are two kinds
of permanencies in our task ontology, that is, the problem solving
permanency and the problem permanency.
The former means that a
conceptual entity remains throughout problem solving but disappears
when completion.
The latter mean that an entity never disappears to
represent the results of problem solving as the consist-of relation in
our example.
The life of each conceptual entities appearing in problem solving
processes is maintained by the version management mechanism of
CLEPE.
The problem solving causality is specified in terms of the
relation among the version changes of the conceptual entities.
'Loop-invariant generate causality' is specified as "if a portion of
problem solving model generates permanent conceptual entities from
loop-invariant ones, there may exist loop-invariant generate
causality."
In our case, the causal relation extracted by the causality
is that "Assign process generates an Assignment which consists of
Picked-up Job and Nurse Selected for the Job in each iteration of
the loop.
The Assignment is added to the Assignment-set which is the
solution to the given problem.
As we can see in the above two examples, the problem solving
causality can extract a meaningful set of relations from the large
number of relations on the problem solving model.
Without it, endusers would be bored with an incontinent talk of meaningless
relations.
6 Capturing the Problem Solving Model
Problem solving causality is built in the task ontology as general
relation among problem solving processes and objects.
As we can
see in the examples of the previous section, by using the problem
solving causality, dynamics of problem solving processes is presented
to end-users as not only the time series of computational operations
but also meaningful causal relations among the changes of objects
with keeping the correspondence between problem solving processes
and domain concept.
The presentation would be well acceptable to
end-users because it appropriately reflects the epistemic characteristic
of their understanding of the problem solving process.
Thus, we could
say that problem solving causality is one of the most important parts
of task ontology as user model.
In this section, we will exemplify the
roles of the problem solving causality as a static user model.
6.1 Problem Solving Causality
Problem solving causality is causal relation among the parts of
problem solving model.
Once the object flow model corresponding
to the given GPN is identified, CLEPE tries to find out causal relation
underlying the problem solving model based on the ontology of
problem solving causality and then build a conceptual level execution
model.
When CLEPE provides end-users with the trace information
of conceptual level execution, the problem solving causality plays
an important role as a basic agreement among end-users and CLEPE
to share the common understanding of the problem solving process.
The major role of the causality, in general, is to assign the role
meaningful from problem solving viewpoint to each of the objects
referred by the relation as arguments.
In general, the causal relation underlying a problem solving model
is quite complicated and entangled.
If one tries to draw the figure to
show the causal relation of a certain problem solving model, he/she
will find that it is too complicated to draw it on one plane.
Thus, it is
quite difficult for end-users to describe the causal relation explicitly
by themselves, even if it is obvious for them.
So, in order for endusers and CLEPE to share the common understanding of the problem
solving model, we cannot expect that end-users to express their
intention by themselves as input to CLEPE.
Instead, CLEPE accepts
rather simple description of problem solving process, such as GPNs,
and then reconstructs the object flow model and reveals the causal
relation underlying it based on task ontology.
In practice, of course,
the reconstruction task is not easy one even with aid of task ontology.
To overcome the difficulty, CLEPE interacts with end-users to reveal
end-users' real intentions of GPN.
Nevertheless, if there still remains
some gap between end-users' intention and CLEPE's understanding,
CLEPE provides end-users with the conceptual level execution
function and expects them to adapt (debug) their problem solving
description to task ontology by themselves.